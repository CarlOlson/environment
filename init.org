#+PROPERTY: header-args :tangle yes
* Utility Functions

#+BEGIN_SRC emacs-lisp
  (defmacro with-system (type &rest body)
    "Evaluate BODY if `system-type' equals TYPE."
    (declare (indent 1))
    `(when (eq system-type ',type)
       ,@body))

  (defun remove-lighter (mode)
    "Remove the lighter from the tray for `mode'."
    (setf (cadr (assoc mode minor-mode-alist)) ""))

  (defun point-to-eol ()
    "Returns the text from current point to the end of line."
    (buffer-substring (point) (point-at-eol)))

  (defmacro for-each-line (&rest body)
    "Evaluate BODY at every line in current buffer."
    `(save-excursion
       (goto-char (point-min))
       (while (not (eq (point) (point-max)))
	 (let ((last-point (point)))
	   ,@body
	   (goto-char last-point)
	   (end-of-line)
	   (forward-char)))))
#+END_SRC

* Interactive Functions
** Formatting

#+BEGIN_SRC emacs-lisp
  (defun reindent-buffer ()
    (interactive)
    (indent-region (point-min) (point-max)))

  (defun sudo-open-buffer ()
    "Open buffer's file with sudo."
    (interactive)
    (find-file (concat "/sudo::" (buffer-file-name))))

  (defun disable-tabs ()
    (interactive)
    (setq-local indent-tabs-mode nil))

  (defun remove-tabs ()
    (interactive)
    (disable-tabs)
    (for-each-line
     (let ((start (point)))
       (back-to-indentation)
       (replace-string "\t" (string-join (make-list tab-width " ")) nil start (point)))))
#+END_SRC

** Navigation

#+BEGIN_SRC emacs-lisp
  (defun select-next-window ()
    (interactive)
    (select-window (next-window)))

  (defun select-prev-window ()
    (interactive)
    (select-window (previous-window)))

  (defmacro point-after-calls (&rest body)
    `(save-excursion
       ,@body
       (point)))

  (defun my-word-boundary-points ()
    (list
     (point-after-calls (forward-word))
     (point-after-calls (backward-word))
     (point-after-calls (back-to-indentation))
     (point-after-calls (next-line) (back-to-indentation))
     (point-after-calls (previous-line) (end-of-line))))

  (defun delete-forward-word ()
    (interactive)
    (let* ((start-point (point))
           (end-point
            (car
             (cl-sort
              (cl-remove-if (lambda (point) (<= point start-point))
                            (my-word-boundary-points))
              '<))))
      (delete-region start-point end-point)))

  (defun delete-backward-word ()
    (interactive)
    (let* ((start-point (point))
           (end-point
            (car
             (cl-sort
              (cl-remove-if (lambda (point) (>= point start-point))
                            (my-word-boundary-points))
              '>))))
      (delete-region start-point end-point)))
#+END_SRC

** Term

#+BEGIN_SRC emacs-lisp
  (defmacro define-key-to-term (key raw)
    "Map key sequence to a raw sequence in `term-mode'."
    `(define-key term-raw-map ,key
       (lambda ()
         (interactive)
         (term-send-raw-string ,raw))))

  (defun term-yank ()
    "Yank from the emacs kill ring."
    (interactive)
    (term-send-raw-string (current-kill 0)))

  (defun term-kill ()
    "Kill line to both emacs and term kill ring."
    (interactive)
    (let* ((text (point-to-eol))
           (eol-pattern (rx (* space) eol))
           (eol-index (string-match eol-pattern text))
           (text (substring text 0 eol-index)))
      (kill-new text)
      (term-send-raw-string "")))

  (defun term-toggle ()
    "Switch between buffer and terminal"
    (interactive)
    (let ((buffer (get-term-buffer)))
      (cond
       ((eq (current-buffer) buffer)
        (previous-buffer)
        (bury-buffer buffer))
       ((null buffer)
        (ansi-term "/bin/zsh"))
       ((null (get-buffer-process buffer))
        (kill-buffer buffer)
        (ansi-term "/bin/zsh"))
       (t
        (switch-to-buffer buffer)))))

  (defun get-term-buffer ()
    (cl-loop
     for buffer in (buffer-list)
     when (term-buffer-p buffer)
     return buffer))

  (defun term-buffer-p (buffer-or-name)
    (string-match-p (rx bol (or "*ansi-term*"
                                "*terminal*"
                                (and "term - " (+ any)))
                        eol)
                    (buffer-name buffer)))
#+END_SRC

** Formatting

#+BEGIN_SRC emacs-lisp
  (defun rename-file-buffer (filename)
    (interactive "F")
    (rename-file (buffer-file-name) filename)
    (set-visited-file-name filename))
#+END_SRC

** Japanese

#+BEGIN_SRC emacs-lisp
  (defun insert-with-input-method (input-method prompt)
    (unwind-protect
        (progn
          (set-input-method input-method)
          (insert-string
           (read-from-minibuffer prompt nil nil nil nil nil t))
          (deactivate-input-method))))

  (defun insert-hiragana ()
    (interactive)
    (insert-with-input-method 'japanese-hiragana "Hiragana: "))

  (defun insert-katakana ()
    (interactive)
    (insert-with-input-method 'japanese-katakana "Katakana: "))
#+END_SRC

* Configuration
** Packages

#+BEGIN_SRC emacs-lisp
  (package-initialize)

  (setq package-archives
        `(("gnu" . "https://elpa.gnu.org/packages/")
          ("melpa" . "https://melpa.org/packages/")))

  (unless package-archive-contents
    (package-refresh-contents))

  (dolist (package '(alchemist
                     avy
                     company
                     company-flx
                     company-jedi
                     elixir-mode
                     form-feed
                     geiser
                     golden-ratio
                     helm
                     helm-rg
                     helm-company
                     helm-projectile
                     helm-tramp
                     magit
                     multiple-cursors
                     projectile
                     rspec-mode
                     session
                     slime
                     slime-company
                     solarized-theme
                     term-projectile
                     undo-tree
                     web-mode))
    (unless (package-installed-p package)
      (package-refresh-contents)
      (package-install package)))
#+END_SRC

** Basic Global Settings

#+BEGIN_SRC emacs-lisp
  (setq inhibit-startup-screen t
        initial-major-mode     'emacs-lisp-mode
        indent-tabs-mode       nil
        make-backup-files      nil
        auto-save-default      nil)

  (set-default 'indent-tabs-mode nil)

  (set-frame-font "-mlss-Anonymous Pro-bold-normal-normal-*-18-*-*-*-m-0-iso10646-1")

  (add-hook 'before-save-hook 'delete-trailing-whitespace)

  (global-auto-revert-mode t)

  (let ((theme 'solarized-light)
        (custom-safe-themes
         '("d677ef584c6dfc0697901a44b885cc18e206f05114c8a3b7fde674fce6180879" default)))
    (when (custom-theme-p theme)
      (load-theme theme t)))

  (menu-bar-mode -1)
  (tool-bar-mode -1)

  (show-paren-mode t)

  (when (display-graphic-p)
    (server-start nil t))

  (with-temp-buffer
    (find-file "~/scratch.el")
    (eval-buffer)
    (kill-buffer))

  (add-to-list 'load-path "~/git/environment/elisp")

  (setq compilation-read-command nil)
#+END_SRC

** Linux

#+BEGIN_SRC emacs-lisp
  (with-system linux
    (add-to-list 'exec-path "/home/carl/.local/bin"))
#+END_SRC

** OSX

For iTerm2 support...
#+BEGIN_SRC emacs-lisp
  (with-system darwin
    (global-set-key (kbd "M-h") 'delete-backward-word)
    (global-set-key (kbd "M-d") 'delete-forward-word))
#+END_SRC

Fix some annoyances with internal keyboards...
#+BEGIN_SRC emacs-lisp
  (with-system darwin
    (keyboard-translate ?\C-u ?\C-x)
    (keyboard-translate ?\C-i ?\C-g)
    (keyboard-translate ?\C-t ?\C-p)
    (global-set-key (kbd "M-u") 'helm-M-x)
    (global-set-key (kbd "C-h") 'delete-backward-char)
    (global-set-key (kbd "C-t") 'previous-line))
#+END_SRC

** Session

#+BEGIN_SRC emacs-lisp
  (unless (package-installed-p 'session)
    (package-install 'session))

  (require 'session)
  (add-hook 'after-init-hook 'session-initialize)
#+END_SRC

** Helm

#+BEGIN_SRC emacs-lisp
  (require 'helm)
  (require 'helm-config)
  (helm-mode 1)
  (remove-lighter 'helm-mode)

  (setq helm-M-x-always-save-history t)

  (add-to-list 'helm-boring-buffer-regexp-list (rx "*ansi-term*"))

  (add-to-list 'helm-find-files-actions '("Insert File Name" . insert) t)
#+END_SRC

** Projectile

#+BEGIN_SRC emacs-lisp
  (require 'projectile)
  (require 'helm-projectile)
  (setq projectile-project-types
        (assq-delete-all 'npm projectile-project-types))

  (projectile-register-project-type 'generic '("script")
                                    :compile "./script/update"
                                    :test "./script/test"
                                    :run "./script/server"
                                    :src-dir "lib"
                                    :test-dir "test"
                                    :test-suffix "_test")

  (projectile-mode +1)
#+END_SRC

** Undo Tree

#+BEGIN_SRC emacs-lisp
  (require 'undo-tree)
  (global-undo-tree-mode 1)
  (remove-lighter 'undo-tree-mode)
#+END_SRC

** Golden Ratio

#+BEGIN_SRC emacs-lisp
  (require 'golden-ratio)
  (add-to-list 'golden-ratio-extra-commands 'select-next-window)
  (add-to-list 'golden-ratio-extra-commands 'quit-window)
  (add-to-list 'golden-ratio-extra-commands 'projectile-test-project)
  (golden-ratio-mode 1)
  (remove-lighter 'golden-ratio-mode)
#+END_SRC

** Avy

#+BEGIN_SRC emacs-lisp
  (setq avy-keys '(?a ?o ?e ?u ?h ?t ?n ?s ?i ?d))
  (setq avy-background t)
#+END_SRC

** Emacs Lisp

#+BEGIN_SRC emacs-lisp
  (add-hook 'emacs-lisp-mode-hook 'company-mode)
  (add-hook 'emacs-lisp-mode-hook 'form-feed-mode)
  (add-hook 'emacs-lisp-mode-hook 'eldoc-mode)
  (add-hook 'emacs-lisp-mode-hook 'disable-tabs)
#+END_SRC

** Common Lisp

#+BEGIN_SRC emacs-lisp
  (let ((file (expand-file-name "~/.roswell/helper.el")))
    (when (file-exists-p file)
      (load file)))

  (with-eval-after-load 'slime
    (setq inferior-lisp-program "ros -Q run")
    (slime-setup '(slime-company slime-repl-ansi-color slime-asdf)))
#+END_SRC

** Scheme

#+BEGIN_SRC emacs-lisp
  (setq geiser-chez-binary "chezscheme9.5"
        geiser-active-implementations '(chez racket))

  (add-hook 'scheme-mode-hook
            (lambda ()
              (add-to-list 'geiser-implementations-alist '((regexp "\\.rkt$") racket ))))

  (add-hook 'scheme-mode-hook 'geiser-mode)
  (add-hook 'scheme-mode-hook 'company-mode)
  (add-hook 'scheme-mode-hook 'eldoc-mode)
  (add-hook 'scheme-mode-hook 'prettify-symbols-mode)
#+END_SRC

** Company Mode

#+BEGIN_SRC emacs-lisp
  (require 'company)
  (company-flx-mode +1)
#+END_SRC

** Org

#+BEGIN_SRC emacs-lisp
  (require 'org)

  (setq org-babel-default-header-args
	(cons '(:tangle . "yes")
	      (assq-delete-all :tangle org-babel-default-header-args)))
#+END_SRC

** Prolog

#+BEGIN_SRC emacs-lisp
  (setq prolog-system 'swi
	prolog-program-name "/usr/bin/swipl")
  (add-to-list 'auto-mode-alist '("\\.pl$" . prolog-mode))
  (add-to-list 'auto-mode-alist '("\\.m$" . mercury-mode))
#+END_SRC

** Python

#+BEGIN_SRC emacs-lisp
  (add-hook 'python-mode-hook 'company-mode)
  (add-to-list 'company-backends 'company-jedi)
#+END_SRC

** Ruby

#+BEGIN_SRC emacs-lisp
  (require 'rspec-mode)
  (setq rspec-use-rvm t
	compilation-scroll-output nil)
#+END_SRC

** Elixir

#+BEGIN_SRC emacs-lisp
  (projectile-register-project-type 'elixir '("mix.exs")
                                    :compile "mix deps.get"
                                    :test "mix test --no-color"
                                    :run "mix app.start"
                                    :src-dir "lib"
                                    :test-dir "test"
                                    :test-suffix "_test"
                                    :related-files-fn 'phx/related-files)

  (defun phx/related-files (path)
    (let* ((filename (file-name-nondirectory path))
           (files (projectile-project-files (projectile-project-root))))
      (when (string-match (rx (group (+ alpha)) "_") filename)
        (let ((prefix (match-string 1 filename)))
          (list :templates (cl-remove-if-not
                            (lambda (file)
                              (string-match (concat "templates/" prefix) file))
                            files))))))

  (define-derived-mode eex-web-mode web-mode "eex-Web"
    "Version of web-mode just for eex files."
    (web-mode-set-engine "elixir"))

  (define-derived-mode leex-web-mode eex-web-mode "leex-Web"
    "Version of web-mode just for leex files.")

  (add-hook 'elixir-mode-hook 'company-mode)
  (setenv "HEX_HTTP_CONCURRENCY" "1")
  (setenv "HEX_HTTP_TIMEOUT"     "60")

  (add-to-list 'auto-mode-alist '("\\.eex?$" . eex-web-mode))
  (add-to-list 'auto-mode-alist '("\\.leex?$" . leex-web-mode))
#+END_SRC

Match test errors correctly in compilation-mode
#+BEGIN_SRC emacs-lisp
  (eval-after-load "compile"
    '(progn
       (add-to-list
        'compilation-error-regexp-alist-alist
        (list 'mix
              (rx " " (group (*? (not whitespace)) "ex" (? "s")) ":" (group (+ digit)) ":")
              1 2 nil nil 1))
       (add-to-list 'compilation-error-regexp-alist 'mix)))
#+END_SRC

Properly wrap exdoc strings
#+BEGIN_SRC emacs-lisp
  (defun ex/hook ()
    (setq-local paragraph-start
                (rx (or (group (* whitespace) num "." (* any) eol)
                        (group (* whitespace) eol))))
    (setq-local paragraph-separate
                (rx (or (group (* any) "\"\"\"" (* whitespace) eol)
                        (group (* whitespace) eol)))))

  (add-hook 'elixir-mode-hook 'ex/hook)
#+END_SRC

** C/C++

#+BEGIN_SRC emacs-lisp
  (when (package-installed-p 'rtags)
    (require 'rtags)
    (unless (rtags-executable-find "rc")
      (message "Cannot find rtags executable!"))
    (setq c-default-style "k&r"
          c-basic-offset 4))
#+END_SRC

** Javascript

#+BEGIN_SRC emacs-lisp
  (projectile-register-project-type 'yarn '("yarn.lock")
                                    :compile "yarn install"
                                    :test "yarn test"
                                    :run "yarn start"
                                    :test-suffix ".spec")

  (define-derived-mode jsx-web-mode web-mode "jsx-Web"
    "Version of web-mode just for js and jsx files."
    (setq-local web-mode-markup-indent-offset 2)
    (setq-local web-mode-code-indent-offset 2)
    (setq-local web-mode-enable-auto-quoting nil)
    (web-mode-set-content-type "jsx"))

  (add-to-list 'auto-mode-alist '("\\.jsx?$" . jsx-web-mode))
#+END_SRC

* Key Bindings
** Global

Disable selection via the mouse!
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "<down-mouse-1>") nil)
  (global-set-key (kbd "<mouse-1>") nil)
#+END_SRC

And everything else...
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-<tab>") 'select-next-window)
  (global-set-key (kbd "<home>") 'beginning-of-buffer)
  (global-set-key (kbd "<end>") 'end-of-buffer)
  (global-set-key (kbd "C-o") 'save-buffer)
  (global-set-key (kbd "C-z") 'undo)

  (global-set-key (kbd "C-x b") 'helm-mini)
  (global-set-key (kbd "C-x C-f") 'helm-find-files)
  (global-set-key (kbd "M-x") 'helm-M-x)
  (global-set-key (kbd "M-y") 'helm-show-kill-ring)
  (global-set-key (kbd "<help> a") 'helm-apropos)

  (global-set-key (kbd "C-S-m") 'backward-word)
  (global-set-key (kbd "C-S-g") 'forward-word)
  (global-set-key (kbd "C-S-d") 'delete-forward-word)
  (global-set-key (kbd "C-S-h") 'delete-backward-word)

  (global-set-key (kbd "<S-left>") 'backward-word)
  (global-set-key (kbd "<S-right>") 'forward-word)
  (global-set-key (kbd "<S-delete>") 'delete-forward-word)
  (global-set-key (kbd "<S-backspace>") 'delete-backward-word)

  (global-set-key (kbd "M-'") 'avy-goto-char-2)

  (global-set-key (kbd "M-.") 'mc/mark-next-like-this-word)
  (global-set-key (kbd "M-,") 'mc/mark-previous-like-this-word)
  (global-set-key (kbd "C-c M-.") 'mc/mark-all-words-like-this)
  (global-set-key (kbd "S-<mouse-1>") 'mc/add-cursor-on-click)

  (global-set-key (kbd "C-c <tab>") 'reindent-buffer)

  (global-set-key (kbd "C-c SPC") 'company-complete)

  (global-set-key (kbd "M-t") 'term-toggle)
#+END_SRC

Builtin Keyboard Support...
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-t") 'previous-line)
#+END_SRC

** Helm

#+BEGIN_SRC emacs-lisp
  (define-key helm-map (kbd "TAB") #'helm-execute-persistent-action)
  (define-key helm-map (kbd "C-z") #'helm-select-action)
#+END_SRC

** Projectile

#+BEGIN_SRC emacs-lisp
  (define-key projectile-mode-map (kbd "C-c C-f") #'helm-projectile-find-file)
  (define-key projectile-mode-map (kbd "C-c C-t") #'projectile-toggle-between-implementation-and-test)
  (define-key projectile-mode-map (kbd "C-c <up>") #'projectile-toggle-between-implementation-and-test)
  (define-key projectile-mode-map (kbd "C-c t") #'projectile-test-project)
  (define-key projectile-mode-map (kbd "C-c r") #'helm-projectile-rg)
  (define-key projectile-mode-map (kbd "C-c g") #'helm-projectile-grep)
#+END_SRC

** Emacs Lisp

#+BEGIN_SRC emacs-lisp
  (define-key emacs-lisp-mode-map (kbd "C-c C-l") 'eval-buffer)
  (define-key emacs-lisp-mode-map (kbd "C-c C-r") 'eval-region)
#+END_SRC

** Org

#+BEGIN_SRC emacs-lisp
  (define-key org-mode-map (kbd "C-<tab>") nil)
  (define-key org-mode-map (kbd "S-<left>") nil)
  (define-key org-mode-map (kbd "S-<right>") nil)
#+END_SRC

** C/C++

#+BEGIN_SRC emacs-lisp
  (when (package-installed-p 'rtags)
    (define-key c-mode-map (kbd "M-v") 'rtags-find-symbol-at-point)
    (define-key c-mode-map (kbd "M-z") 'rtags-location-stack-back))
#+END_SRC

** Term

#+BEGIN_SRC emacs-lisp
  (require 'term)
  (define-key term-raw-map (kbd "C-k") 'term-kill)
  (define-key term-raw-map (kbd "C-y") 'term-yank)
  (define-key term-raw-map (kbd "C-x") nil)
  (define-key term-raw-map (kbd "M-x") nil)
  (define-key term-raw-map (kbd "M-t") 'term-toggle)

  ;; External keyboard
  (define-key-to-term (kbd "<S-left>")      "\eb")
  (define-key-to-term (kbd "<S-right>")     "\ef")
  (define-key-to-term (kbd "<S-backspace>") "\eh")
  (define-key-to-term (kbd "<S-delete>")    "\ed")

  ;; Internal keyboard
  (define-key-to-term (kbd "S-RET") "\eb")
  (define-key-to-term (kbd "C-S-g") "\ef")
  (define-key-to-term (kbd "C-S-h") "\eh")
  (define-key-to-term (kbd "C-S-d") "\ed")

  ;; Remapping shaddowed commands
  (define-key-to-term (kbd "C-x f") (kbd "C-u f"))
  (define-key-to-term (kbd "C-x C-f") (kbd "C-u C-f"))
#+END_SRC
